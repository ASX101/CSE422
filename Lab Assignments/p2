from collections import deque

def bfs_shortest_distance(graph, start, goal, n):
    if start == goal:
        return 0
    
    queue = deque([(start, 0)])
    visited = set([start])
    while queue:
        current, distance = queue.popleft()
        
        for neighbor in graph[current]:
            if neighbor == goal:
                return distance + 1
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append((neighbor, distance + 1))
    return float('inf')

def check_admissibility(graph, heuristics, start, goal, n):
    inadmissible_nodes = []
    
    for vertex in range(1, n + 1):
        h_value = heuristics[vertex]
        actual_distance = bfs_shortest_distance(graph, vertex, goal, n)
        
        if h_value > actual_distance:
            inadmissible_nodes.append(vertex)
            
    is_admissible = len(inadmissible_nodes) == 0
    
    return is_admissible, inadmissible_nodes